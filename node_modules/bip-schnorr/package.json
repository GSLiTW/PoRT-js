{
  "_from": "bip-schnorr@^0.3.0",
  "_id": "bip-schnorr@0.3.0",
  "_inBundle": false,
  "_integrity": "sha512-Sc1Hn2+1n+okPEW8G+JLjeaM12dsUOwr+oFlMDSKR9wYwNGMw0alskeBIHTmXxBxMZSWKhCW7PwKQVDyGmnaVg==",
  "_location": "/bip-schnorr",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "bip-schnorr",
    "fetchSpec": "^0.3.0",
    "name": "bip-schnorr",
    "raw": "bip-schnorr@^0.3.0",
    "rawSpec": "^0.3.0",
    "registry": true,
    "saveSpec": null,
    "type": "range"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/bip-schnorr/-/bip-schnorr-0.3.0.tgz",
  "_shasum": "e6490379603704e9dd123d874b41755aea4f352c",
  "_spec": "bip-schnorr@^0.3.0",
  "_where": "/mnt/c/Users/leowa/Desktop/GoogleDrive/PoRT-Blockchain",
  "author": {
    "email": "gugger@gmail.com",
    "name": "Oliver Gugger"
  },
  "bugs": {
    "url": "https://github.com/guggero/bip-schnorr/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "ecurve": "^1.0.6",
    "js-sha256": "^0.9.0",
    "random-bytes": "^1.0.0",
    "safe-buffer": "^5.0.1"
  },
  "deprecated": false,
  "description": "Pure JavaScript implementation of the BIP schnorr signature scheme and the muSig multi-signature scheme",
  "devDependencies": {
    "benchmark": "^2.1.4",
    "coveralls": "^3.0.0",
    "microtime": "^3.0.0",
    "mocha": "^6.0.2",
    "nyc": "^13.3.0"
  },
  "engines": {
    "node": ">=8.0.0"
  },
  "homepage": "https://github.com/guggero/bip-schnorr#readme",
  "keywords": [
    "bip",
    "curve",
    "elliptic",
    "muSig",
    "multi-signature",
    "schnorr"
  ],
  "license": "MIT",
  "main": "./src/index.js",
  "name": "bip-schnorr",
  "optionalDependencies": {},
  "readme": "# Pure JavaScript implementation of the Schnorr BIP\n\n[![Build Status](https://travis-ci.org/guggero/bip-schnorr.svg?branch=master)](https://travis-ci.org/guggero/bip-schnorr)\n[![Coverage Status](https://coveralls.io/repos/github/guggero/bip-schnorr/badge.svg?branch=master)](https://coveralls.io/github/guggero/bip-schnorr?branch=master)\n[![Open Source Love](https://badges.frapsoft.com/os/mit/mit.svg?v=102)](https://github.com/ellerbrock/open-source-badge/)\n\n[![npm version](https://badge.fury.io/js/bip-schnorr.svg)](https://badge.fury.io/js/bip-schnorr)\n[![Dependency Status](https://david-dm.org/guggero/bip-schnorr.svg)](https://david-dm.org/guggero/bip-schnorr)\n[![devDependency Status](https://david-dm.org/guggero/bip-schnorr/dev-status.svg)](https://david-dm.org/guggero/bip-schnorr#info=devDependencies)\n\nThis is a pure JavaScript implementation of the standard 64-byte Schnorr signature\nscheme over the elliptic curve *secp256k1* and its application in the\n`MuSig` [multi-signature scheme proposed by Blockstream](https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures/).\n\nThe code is based upon the\n[initial proposal of Pieter Wuille](https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki)\nwhen it didn't have a BIP number assigned yet.\n\nThe MuSig implementation is based upon the C implementation in the\n[secp256k1-zkp fork](https://github.com/ElementsProject/secp256k1-zkp)\n\nI am by no means an expert in high performance JavaScript or the underlying cryptography.\nSo this library is probably really slow.\n\nThe current version passes all test vectors provided\n[here](https://raw.githubusercontent.com/sipa/bips/bip-schnorr/bip-schnorr/test-vectors.csv).  \n**But the author does not give any guarantees that the algorithm is implemented\ncorrectly for every edge case!**\n\nThe BIP and C reference implementations are still under development so the API of\nthis implementation is also not yet stable and can change when the reference implementation changes. \n\n## How to install\n\n**NPM**:\n```bash\nnpm install --save bip-schnorr\n```\n\n**yarn**:\n```bash\nyarn add bip-schnorr\n```\n\n\n## How to use\n\nNOTE: All parameters are either of type `BigInteger` or `Buffer` (or an array of those).\n\n### Schnorr\n\n```javascript\nconst schnorr = require('bip-schnorr');\nconst convert = schnorr.convert;\n\n// signing\nconst privateKey = BigInteger.fromHex('B7E151628AED2A6ABF7158809CF4F3C762E7160F38B4DA56A784D9045190CFEF');\nconst message = Buffer.from('243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89', 'hex');\nconst createdSignature = schnorr.sign(privateKey, message);\nconsole.log('The signature is: ' + createdSignature.toString('hex'));\n\n// verifying\nconst publicKey = Buffer.from('02DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659', 'hex');\nconst signatureToVerify = Buffer.from('2A298DACAE57395A15D0795DDBFD1DCB564DA82B0F269BC70A74F8220429BA1D1E51A22CCEC35599B8F266912281F8365FFC2D035A230434A1A64DC59F7013FD', 'hex');\ntry {\n  schnorr.verify(publicKey, message, signatureToVerify);\n  console.log('The signature is valid.');\n} catch (e) {\n  console.error('The signature verification failed: ' + e);\n}\n\n// batch verifying\nconst publicKeys = [\n  Buffer.from('02DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659', 'hex'),\n  Buffer.from('03FAC2114C2FBB091527EB7C64ECB11F8021CB45E8E7809D3C0938E4B8C0E5F84B', 'hex'),\n  Buffer.from('026D7F1D87AB3BBC8BC01F95D9AECE1E659D6E33C880F8EFA65FACF83E698BBBF7', 'hex'),\n];\nconst messages = [\n  Buffer.from('243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89', 'hex'),\n  Buffer.from('5E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C', 'hex'),\n  Buffer.from('B2F0CD8ECB23C1710903F872C31B0FD37E15224AF457722A87C5E0C7F50FFFB3', 'hex'),\n];\nconst signatures = [\n  Buffer.from('2A298DACAE57395A15D0795DDBFD1DCB564DA82B0F269BC70A74F8220429BA1D1E51A22CCEC35599B8F266912281F8365FFC2D035A230434A1A64DC59F7013FD', 'hex'),\n  Buffer.from('00DA9B08172A9B6F0466A2DEFD817F2D7AB437E0D253CB5395A963866B3574BE00880371D01766935B92D2AB4CD5C8A2A5837EC57FED7660773A05F0DE142380', 'hex'),\n  Buffer.from('68CA1CC46F291A385E7C255562068357F964532300BEADFFB72DD93668C0C1CAC8D26132EB3200B86D66DE9C661A464C6B2293BB9A9F5B966E53CA736C7E504F', 'hex'),\n];\ntry {\n  schnorr.batchVerify(publicKeys, messages, signatures);\n  console.log('The signatures are valid.');\n} catch (e) {\n  console.error('The signature verification failed: ' + e);\n}\n\n// aggregating signatures (naive Schnorr key aggregation, not part of BIP, not safe against rogue-key-attack!)\nconst privateKey1 = BigInteger.fromHex('B7E151628AED2A6ABF7158809CF4F3C762E7160F38B4DA56A784D9045190CFEF');\nconst privateKey2 = BigInteger.fromHex('C90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B14E5C7');\nconst message = Buffer.from('243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89', 'hex');\nconst aggregatedSignature = schnorr.naiveKeyAggregation([privateKey1, privateKey2], message);\n\n// verifying an aggregated signature\nconst publicKey1 = Buffer.from('02DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659', 'hex');\nconst publicKey2 = Buffer.from('03FAC2114C2FBB091527EB7C64ECB11F8021CB45E8E7809D3C0938E4B8C0E5F84B', 'hex');\nconst sumOfPublicKeys = convert.pubKeyToPoint(publicKey1).add(convert.pubKeyToPoint(publicKey2));\ntry {\n  schnorr.verify(convert.pointToBuffer(sumOfPublicKeys), message, aggregatedSignature);\n  console.log('The signature is valid.');\n} catch (e) {\n  console.error('The signature verification failed: ' + e);\n}\n````\n\n### muSig non-interactive\n\n```javascript\nconst schnorr = require('bip-schnorr');\nconst convert = schnorr.convert;\n\n// muSig non-interactive (not part of any BIP yet, see https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures/)\nconst privateKey1 = BigInteger.fromHex('B7E151628AED2A6ABF7158809CF4F3C762E7160F38B4DA56A784D9045190CFEF');\nconst privateKey2 = BigInteger.fromHex('C90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B14E5C7');\nconst message = Buffer.from('243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89', 'hex');\nconst aggregatedSignature = schnorr.muSig.nonInteractive([privateKey1, privateKey2], message);\n\n// verifying an aggregated signature\nconst publicKey1 = Buffer.from('02DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659', 'hex');\nconst publicKey2 = Buffer.from('03FAC2114C2FBB091527EB7C64ECB11F8021CB45E8E7809D3C0938E4B8C0E5F84B', 'hex');\nconst X = schnorr.muSig.pubKeyCombine([publicKey1, publicKey2]);\ntry {\n  schnorr.verify(convert.pointToBuffer(X), message, aggregatedSignature);\n  console.log('The signature is valid.');\n} catch (e) {\n  console.error('The signature verification failed: ' + e);\n}\n```\n\n### muSig\n\n```javascript\nconst randomBytes = require('random-bytes');\nconst randomBuffer = (len) => Buffer.from(randomBytes.sync(len));\nconst schnorr = require('bip-schnorr');\nconst convert = schnorr.convert;\nconst muSig = schnorr.muSig;\n\n// data known to every participant\nconst publicData = {\n  pubKeys: [\n    Buffer.from('03846f34fdb2345f4bf932cb4b7d278fb3af24f44224fb52ae551781c3a3cad68a', 'hex'),\n    Buffer.from('02cd836b1d42c51d80cef695a14502c21d2c3c644bc82f6a7052eb29247cf61f4f', 'hex'),\n    Buffer.from('03b8c1765111002f09ba35c468fab273798a9058d1f8a4e276f45a1f1481dd0bdb', 'hex'),\n  ],\n  message: convert.hash(Buffer.from('muSig is awesome!', 'utf8')),\n  pubKeyHash: null,\n  pubKeyCombined: null,\n  commitments: [],\n  nonces: [],\n  nonceCombined: null,\n  partialSignatures: [],\n  signature: null,\n};\n\n// data only known by the individual party, these values are never shared\n// between the signers!\nconst signerPrivateData = [\n  // signer 1\n  {\n    privateKey: BigInteger.fromHex('add2b25e2d356bec3770305391cbc80cab3a40057ad836bcb49ef3eed74a3fee'),\n    session: null,\n  },\n  // signer 2\n  {\n    privateKey: BigInteger.fromHex('0a1645eef5a10e1f5011269abba9fd85c4f0cc70820d6f102fb7137f2988ad78'),\n    session: null,\n  },\n  // signer 3\n  {\n    privateKey: BigInteger.fromHex('2031e7fed15c770519707bb092a6337215530e921ccea42030c15d86e8eaf0b8'),\n    session: null,\n  }\n];\n\n// -----------------------------------------------------------------------\n// Step 1: Combine the public keys\n// The public keys P_i are combined into the combined public key P.\n// This can be done by every signer individually or by the initializing\n// party and then be distributed to every participant.\n// -----------------------------------------------------------------------\npublicData.pubKeyHash = muSig.computeEll(publicData.pubKeys);\npublicData.pubKeyCombined = muSig.pubKeyCombine(publicData.pubKeys, publicData.pubKeyHash);\n\n// -----------------------------------------------------------------------\n// Step 2: Create the private signing session\n// Each signing party does this in private. The session ID *must* be\n// unique for every call to sessionInitialize, otherwise it's trivial for\n// an attacker to extract the secret key!\n// -----------------------------------------------------------------------\nsignerPrivateData.forEach((data, idx) => {\n  const sessionId = randomBuffer(32); // must never be reused between sessions!\n  data.session = muSig.sessionInitialize(\n    sessionId,\n    data.privateKey,\n    publicData.message,\n    publicData.pubKeyCombined,\n    publicData.pubKeyHash,\n    idx\n  );\n});\nconst signerSession = signerPrivateData[0].session;\n\n// -----------------------------------------------------------------------\n// Step 3: Exchange commitments (communication round 1)\n// The signers now exchange the commitments H(R_i). This is simulated here\n// by copying the values from the private data to public data array.\n// -----------------------------------------------------------------------\nfor (let i = 0; i < publicData.pubKeys.length; i++) {\n  publicData.commitments[i] = signerPrivateData[i].session.commitment;\n}\n\n// -----------------------------------------------------------------------\n// Step 4: Get nonces (communication round 2)\n// Now that everybody has commited to the session, the nonces (R_i) can be\n// exchanged. Again, this is simulated by copying.\n// -----------------------------------------------------------------------\nfor (let i = 0; i < publicData.pubKeys.length; i++) {\n  publicData.nonces[i] = signerPrivateData[i].session.nonce;\n}\n\n// -----------------------------------------------------------------------\n// Step 5: Combine nonces\n// The nonces can now be combined into R. Each participant should do this\n// and keep track of whether the nonce was negated or not. This is needed\n// for the later steps.\n// -----------------------------------------------------------------------\npublicData.nonceCombined = muSig.sessionNonceCombine(signerSession, publicData.nonces);\nsignerPrivateData.forEach(data => (data.session.nonceIsNegated = signerSession.nonceIsNegated));\n\n// -----------------------------------------------------------------------\n// Step 6: Generate partial signatures\n// Every participant can now create their partial signature s_i over the\n// given message.\n// -----------------------------------------------------------------------\nsignerPrivateData.forEach(data => {\n  data.session.partialSignature = muSig.partialSign(data.session, publicData.message, publicData.nonceCombined, publicData.pubKeyCombined);\n});\n\n// -----------------------------------------------------------------------\n// Step 7: Exchange partial signatures (communication round 3)\n// The partial signature of each signer is exchanged with the other\n// participants. Simulated here by copying.\n// -----------------------------------------------------------------------\nfor (let i = 0; i < publicData.pubKeys.length; i++) {\n  publicData.partialSignatures[i] = signerPrivateData[i].session.partialSignature;\n}\n\n// -----------------------------------------------------------------------\n// Step 8: Verify individual partial signatures\n// Every participant should verify the partial signatures received by the\n// other participants.\n// -----------------------------------------------------------------------\nfor (let i = 0; i < publicData.pubKeys.length; i++) {\n  muSig.partialSigVerify(\n    signerSession,\n    publicData.partialSignatures[i],\n    publicData.nonceCombined,\n    i,\n    publicData.pubKeys[i],\n    publicData.nonces[i]\n  );\n}\n\n// -----------------------------------------------------------------------\n// Step 9: Combine partial signatures\n// Finally, the partial signatures can be combined into the full signature\n// (s, R) that can be verified against combined public key P.\n// -----------------------------------------------------------------------\npublicData.signature = muSig.partialSigCombine(publicData.nonceCombined, publicData.partialSignatures);\n\n// -----------------------------------------------------------------------\n// Step 10: Verify signature\n// The resulting signature can now be verified as a normal Schnorr\n// signature (s, R) over the message m and public key P.\n// -----------------------------------------------------------------------\nschnorr.verify(publicData.pubKeyCombined, publicData.message, publicData.signature);\n```\n\n## API\n\n### schnorr.sign(privateKey : BigInteger, message : Buffer) : Buffer\nSign a 32-byte message with the private key, returning a 64-byte signature.\n\n### schnorr.verify(pubKey : Buffer, message : Buffer, signature : Buffer) : void\nVerify a 64-byte signature of a 32-byte message against the public key. Throws an `Error` if verification fails.\n\n### schnorr.batchVerify(pubKeys : Buffer[], messages : Buffer[], signatures : Buffer[]) : void\nVerify a list of 64-byte signatures as a batch operation. Throws an `Error` if verification fails.\n\n### schnorr.naiveKeyAggregation(privateKeys : BigInteger[], message : Buffer) : Buffer\nAggregates multiple signatures of different private keys over the same message into a single 64-byte signature.\n\nThis is just a demo of how the naive Schnorr multi-signature (or key aggregation scheme) can work.  \n**This scheme is not secure,** it is prone to so-called rogue-key attacks.  \nSee [Key Aggregation for Schnorr Signatures](https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures/)\nby Blockstream.\n\nUse the **muSig** scheme that prevents that attack.\n\n### schnorr.muSig.nonInteractive(privateKeys : BigInteger[], message : Buffer) : Buffer\nAggregates multiple signatures of different private keys over the same message into a single 64-byte signature\nusing a scheme that is safe from rogue-key attacks.\n\nThis non-interactive scheme requires the knowledge of all private keys that are participating in the\nmulti-signature creation. Use the **MuSig interactive** scheme that requires multiple steps to create\na signature with parties not sharing their private key (see below).\n\n### schnorr.muSig.computeEll(pubKeys : Buffer[]) : Buffer\nGenerate `ell` which is the hash over all public keys participating in a muSig session.\n\n### schnorr.muSig.pubKeyCombine(pubKeys : Buffer[], pubKeyHash : Buffer) : Buffer\nCreates the special rogue-key-resistant combined public key `P` by applying the MuSig coefficient\nto each public key `P_i` before adding them together.\n\n### schnorr.muSig.sessionInitialize(sessionId : Buffer, privateKey : BigInteger, message : Buffer, pubKeyCombined : Buffer, ell : Buffer, idx : number) : Session\nCreates a signing session. Each participant must create a session and *must not share* the content\nof the session apart from the commitment and later the nonce.\n\n**It is absolutely necessary that the session ID\nis unique for every call of `sessionInitialize`. Otherwise\nit's trivial for an attacker to extract the secret key!**\n\n### schnorr.muSig.sessionNonceCombine(session : Session, nonces : Buffer[]) : Buffer\nCombines multiple nonces `R_i` into the combined nonce `R`.\n\n### schnorr.muSig.partialSign(session : Session, message : Buffer, nonceCombined : Buffer, pubKeyCombined : Buffer) : BigInteger\nCreates a partial signature `s_i` for a participant.\n\n### schnorr.muSig.partialSigVerify(session : Session, partialSig : BigInteger, nonceCombined : Buffer, idx : number, pubKey : Buffer, nonce : Buffer) : void\nVerifies a partial signature `s_i` against the participant's public key `P_i`.\nThrows an `Error` if verification fails.\n\n### schnorr.muSig.partialSigCombine(nonceCombined : Buffer, partialSigs : BigInteger[]) : Buffer\nCombines multiple partial signatures into a Schnorr signature `(s, R)` that can be verified against\nthe combined public key `P`.\n\n## Implementations in different languages\n* [Go implementation](https://github.com/hbakhtiyor/schnorr/)\n\n## Performance\n\nThe code is not yet optimized for performance.\n\nThe following results were achieved on an Intel Core i7-6500U running on linux/amd64 with node v10.15.0:\n\n```text\n$ node test/schnorr.benchmark.js\nSign (batch size: 1) x 29.81 ops/sec ±2.23% (53 runs sampled) 35344 us/op 28 sig/s\nSign (batch size: 2) x 15.28 ops/sec ±1.99% (42 runs sampled) 67103 us/op 30 sig/s\nSign (batch size: 4) x 7.51 ops/sec ±1.98% (23 runs sampled) 134388 us/op 30 sig/s\nSign (batch size: 8) x 3.83 ops/sec ±2.27% (14 runs sampled) 260547 us/op 31 sig/s\nSign (batch size: 16) x 1.92 ops/sec ±0.99% (9 runs sampled) 525121 us/op 30 sig/s\nSign (batch size: 32) x 0.96 ops/sec ±2.78% (7 runs sampled) 1044533 us/op 31 sig/s\nSign (batch size: 64) x 0.48 ops/sec ±1.51% (6 runs sampled) 2072564 us/op 31 sig/s\nVerify (batch size: 1) x 29.96 ops/sec ±0.77% (53 runs sampled) 34513 us/op 29 sig/s\nVerify (batch size: 2) x 15.30 ops/sec ±0.70% (42 runs sampled) 67126 us/op 30 sig/s\nVerify (batch size: 4) x 7.64 ops/sec ±1.03% (23 runs sampled) 132236 us/op 30 sig/s\nVerify (batch size: 8) x 3.85 ops/sec ±1.02% (14 runs sampled) 261091 us/op 31 sig/s\nVerify (batch size: 16) x 1.93 ops/sec ±0.53% (9 runs sampled) 519554 us/op 31 sig/s\nVerify (batch size: 32) x 0.97 ops/sec ±0.64% (7 runs sampled) 1033222 us/op 31 sig/s\nVerify (batch size: 64) x 0.48 ops/sec ±0.69% (6 runs sampled) 2079248 us/op 31 sig/s\nBatch Verify (batch size: 1) x 30.55 ops/sec ±0.93% (54 runs sampled) 33736 us/op 30 sig/s\nBatch Verify (batch size: 2) x 12.35 ops/sec ±0.88% (35 runs sampled) 82398 us/op 24 sig/s\nBatch Verify (batch size: 4) x 5.64 ops/sec ±1.25% (18 runs sampled) 178555 us/op 22 sig/s\nBatch Verify (batch size: 8) x 2.71 ops/sec ±0.83% (11 runs sampled) 370195 us/op 22 sig/s\nBatch Verify (batch size: 16) x 1.32 ops/sec ±0.72% (8 runs sampled) 760835 us/op 21 sig/s\nBatch Verify (batch size: 32) x 0.66 ops/sec ±0.52% (6 runs sampled) 1523772 us/op 21 sig/s\nBatch Verify (batch size: 64) x 0.33 ops/sec ±0.41% (5 runs sampled) 3061443 us/op 21 sig/s\nAggregate Signatures naive (batch size: 1) x 31.36 ops/sec ±0.76% (55 runs sampled) 33094 us/op 30 sig/s\nAggregate Signatures naive (batch size: 2) x 15.49 ops/sec ±0.83% (42 runs sampled) 66253 us/op 30 sig/s\nAggregate Signatures naive (batch size: 4) x 7.80 ops/sec ±1.06% (24 runs sampled) 128978 us/op 31 sig/s\nAggregate Signatures naive (batch size: 8) x 3.97 ops/sec ±0.22% (14 runs sampled) 254682 us/op 31 sig/s\nAggregate Signatures naive (batch size: 16) x 1.95 ops/sec ±0.78% (9 runs sampled) 515667 us/op 31 sig/s\nAggregate Signatures naive (batch size: 32) x 0.98 ops/sec ±0.53% (7 runs sampled) 1023110 us/op 31 sig/s\nAggregate Signatures naive (batch size: 64) x 0.49 ops/sec ±0.60% (6 runs sampled) 2038238 us/op 31 sig/s\nAggregate Signatures MuSig non-interactive (batch size: 1) x 19.99 ops/sec ±1.07% (37 runs sampled) 51157 us/op 20 sig/s\nAggregate Signatures MuSig non-interactive (batch size: 2) x 9.91 ops/sec ±1.68% (29 runs sampled) 102176 us/op 20 sig/s\nAggregate Signatures MuSig non-interactive (batch size: 4) x 4.99 ops/sec ±1.23% (17 runs sampled) 201754 us/op 20 sig/s\nAggregate Signatures MuSig non-interactive (batch size: 8) x 2.51 ops/sec ±0.75% (11 runs sampled) 400945 us/op 20 sig/s\nAggregate Signatures MuSig non-interactive (batch size: 16) x 1.26 ops/sec ±0.72% (8 runs sampled) 792623 us/op 20 sig/s\nAggregate Signatures MuSig non-interactive (batch size: 32) x 0.62 ops/sec ±2.60% (6 runs sampled) 1618385 us/op 20 sig/s\nAggregate Signatures MuSig non-interactive (batch size: 64) x 0.32 ops/sec ±0.71% (5 runs sampled) 3171948 us/op 20 sig/s\nDone in 422.45s.\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/guggero/bip-schnorr.git"
  },
  "scripts": {
    "benchmark": "node test/schnorr.benchmark.js",
    "coverage": "nyc --check-coverage --branches 85 --functions 90 --lines 90 mocha ./test/schnorr-*.spec.js",
    "coverage-coveralls": "nyc mocha ./test/schnorr-*.spec.js && nyc report --reporter=text-lcov | coveralls",
    "coverage-html": "nyc report --reporter=html",
    "test": "yarn run coverage",
    "unit": "mocha ./test/schnorr-*.spec.js"
  },
  "version": "0.3.0"
}
